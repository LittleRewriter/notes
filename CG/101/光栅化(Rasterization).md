# 光栅化(Rasterization)

我们常常定义长宽比(aspect ratio)和可视角(field of view)。有这两个定义，就相当于规定了透视投影的视锥。

可视角分成了水平方向的可视角和垂直方向的可视角。

那么假如视口上坐标是$(0,t,n)$，垂直可视角$fovY$，长宽比$aspect$，有
$$
\tan \frac{fovY}{2} = \frac{t}{|n|}
$$

$$
aspect = \frac{r}{t}
$$

下面我们考察MVP之后要做的事情，也就是把得到的Canonical Cube转化到屏幕上。

先定义屏幕。屏幕是一个像素的二维数组，这个数组的大小叫做分辨率(resolution)。光栅(raster)其实是德语中的屏幕，而rasterize就是将元素画到屏幕上的过程。

像素(pixel)是picture element的缩写，可以理想化的认为是一个具有颜色的色块。

下面定义屏幕空间。定义屏幕左下角是屏幕空间的原点，任意一个像素的坐标就可以用(x,y)表示。假如屏幕的像素是$w\times h$，那么坐标的取值就是$[0,w-1]\times[0,h-1]$。而事实上，像素$(x,y)$的中心位于$(x+0.5,y+0.5)$。

从canonical cube变换到screen的变换矩阵是非常简单的：
$$
M_{viewport} = \pmatrix{w/2&0&0&w/2\\0&h/2&0&h/2\\0&0&1&0\\0&0&0&1}
$$
这就是视口变换。

再舍弃掉y分量，得到的就是视口空间下的坐标。

下面就需要进行光栅化。模型空间中的多边形，变换到屏幕空间的多边形，最终转化到屏幕上的像素，这是光栅化的核心。

三角形是最基本的多边形，任何一个多边形都可以拆成三角形，也可以保证具有平面性。同时，三角形很清晰的判断内外，而且只要有三角形顶点的属性，就可以插值计算出其他点的属性。所以，我们先讨论三角形光栅。

最简单的做法就是采样(sampling)。例如，给出一个$f(x)=\sin x$，通过得到$f(1),f(2),\cdots$得到一个函数表，称为采样。也就是离散化。

可以根据像素中心对屏幕进行采样。只判断像素中心：
$$
\text{inside}(t,x,y) = \cases{1 & \text{center in the triangle} \\ 0 & otherwise}
$$
从而，

```c++
for(int x = 0; x < w; ++x) {
    for(int y = 0; y < h; ++y) {
        image[x][y] = inside(tri,x+0.5,y+0.5);
    }
}
```

那么这个函数具体如何实现呢？我们之前已经在叉积部分讨论过了：做三次叉积即可。

假如某个点同时位于两个三角形内，那么这个定义是由自己规定的，只要合理即可。

但是我们也发现，这样的采样过程是$O(vhn)$，$n$是三角形个数。这个代价是非常大的，那如何优化呢？可以先找到三角形包围和，也就是一个包括三角形的长方形”盒子“(轴向包围盒，axis aligned bounding box, AABB)。我们只需要在这个盒子内讨论光栅化，这样计算的代价会减少。

当然有一系列的光栅化优化。例如，对于某一行分别建立一个bouding box等。

但是，这样的后果就是——锯齿(jaggies)，或者说走样(aliasing)。

下面我们就来试图解决反走样(antialiasing)的问题。

常见的artifact有下面的形式

- 锯齿, sampling in space
- 摩尔纹(Moire), undersampling images
- Wagon wheel effect, sampling in time

这些本质都是因为变化过于迅速和采样频率不足的矛盾而产生的。

而解决方法就是一个采样之前的滤波（Pre filter），可以认为是对原始信号进行了“模糊”处理，稀释了锯齿的走样。

下面分析为什么这种解决方法具有合理性。

从傅里叶变换的角度来考虑
$$
F(\omega) = \int_{-\infty}^{+\infty} f(x)e^{-2\pi i\omega x}dx
$$
就可以将任意一个信号转到频域去。

对于高频信号，我们往往需要更频繁的采样。否则，很多额外信息就会消失。

这就是为什么车轮会逆着转——因为人眼采样频率不够，所以信号失真了。这也是摩尔纹的来源——因为采样频率不够，所以恢复出的照片精度不够。

两个信号虽然频率不同，但是按照某一频率去采样，得到的结果一样而无法区分。这就是alias的正规定义。

什么叫滤波？滤波就是过滤掉特定频率的信号。

对于图片来说，定义中间的是低频信息，周围的是高频信息。大部分图片都是低频信号为主。傅里叶变换可以将图片的信号转换成频谱。

而如果我们过滤掉这些低频信号呢？这种 **高通滤波** 的后果就是，高频信号通过了，这些高频信息往往出现在图片的边界。

某种意义上，filtering = convolution(卷积) = averaging。

假设signal的数列是$\{a_n\}$,Filtering的数列是$\{b_n\}$，定义
$$
(a * b)_n = \sum_{n-k/2}^{n+k/2} a_i b_j
$$
有卷积定理：时域上的卷积等于频域上的乘积。将图片先变化，然后乘上卷积盒的变化，就可以得到新的图片。

再考虑采样。对函数$f(x)$，那么对$f(x)$的采样某种意义上就是$f(x)\cdot g(x)$，其中$g(x)$是一系列的单位阶跃函数。用卷积定理，相当于频域上卷积——得到的是一系列的周期延拓。

可是如果采样间隔不够，原始的信号在周期延拓之后间隔很小。那么就有可能信号之间发生重叠，导致走样产生了！

那么反走样究竟做了什么事情？因为在这种情况下，高频信号消失掉了，频率混叠的影响就会大幅度减少。

在实际操作中，我们一般使用一个1像素单位的box filter，作为一个低通滤波器，起到模糊操作的作用。总的来说，就是

- Colvolve f(x,y) by a 1-pixel box blur
- Sample

这样实际上相当于对像素内部求平均，而这恰恰相当于取覆盖部分的面积除以像素的大小，作为灰度值。

这个操作是很复杂的，有一个近似算法MSAA(Antialiasing By Supersampling)，即过采样。对每个小像素进行多个采样，将结果进行平均——这其实就是对覆盖区域的近似。 

但要注意，这并不是提高采样率，只是为了求出一个更好的覆盖。

MSAA会提高复杂度，工业界很多时候并不会完全使用规则的点分布，有些时候需要按照某些规律来分布点数。

此外还有一些抗锯齿的方法：

- FXAA(Fast Approximate AA)，快速近似抗锯齿，是一个图像后期处理，与采样操作无关。
- TAA(Temporal AA)，借助上一帧的像素来进行下·分析。复用上一帧感知的结果，得到新的帧。

除此之外，我们还需要相互遮挡的问题——Z-buffer。

物体的渲染一般是从远到近的。例如在创作一副油画，先画一座山，再画草地，再画数，……最终某些东西被遮挡了，但是最终得到的正确结果。这就是油画家所采用的方法——Painter's Algorithm。

放到图形学中，假如用画家算法，先画最远的面，然后画周围四个面，最后画中间的面，得到了正确的结果。可是如果先画上面再画右面，可能会多点不应该存在的东西，而这是很糟糕的。

再考虑下面这个繁杂的例子。R、Q、P是三个三角形，两两存在覆盖关系。他们的覆盖关系成了一个环，这就导致这种覆盖关系失效了！所以，实际做法中是不能使用画家算法的。

这就是为什么引入Z-Buffer。

虽然直接排序物体是很难的，但是我们可以对每个像素进行排序。在生成图像的时候，生成一张深度图(depth buffer)和一张场景图(frame buffer)来维护深度信息。

具体来说，

```lua
init zbuffer as inf
foreach(triangle T) {
    foreach(sample (x, y, z) in T) {
        if (z < zbuffer(x,y))
            framebuffer(x,y) = rgb
            zbuffer(x,y) = z;
    }
}
```

复杂度$O(kn)$，$k$为三角形平均覆盖的像素个数。

如果想得到更漂亮的结果，可以对MSAA的结果做深度测试。