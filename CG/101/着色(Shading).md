# 着色(Shading)

在不同位置，颜色会出现变化，主要是明暗，这些因素会影响真实感。

在图形学中，shading就是"the process of applying a material to an object"。

球，可以是一个石膏球，可以是一个木头球，....这些和光线作用方法的不同影响了最终的效果。

## Blinn-Phong Reflectance Model

我们先来介绍最简单的着色模型——Blinn-Phong Reflectance Model。

一个物体的光分成几个部分：

- Specular highlights，高光
- Diffuse reflection，漫反射
- Ambient reflection，环境光

比较复杂的是第三部分。例如，一个光打到物体旁的墙面上发生漫反射，之后再反射到物体的后面，这部分反而照亮了物体——这就是来自于环境的反射光。

定义

- $\vec v$ 观察向量
- $\vec n$ 表面法线
- $\vec l$ 光照方向
- 表面参数（color, shininess，...）

着色具有局部性。我们只能看到明暗变化，但是并看不到阴影——这之后再说。

先考虑漫反射。考虑到光是一种能量，那么接收到的能量 
$$
I = I_0 \cos (\vec v, \vec n)
$$
而发射能量的时候，可以认为其发射遵循一个球壳的变化规律，按照时间衰减。球壳表面积越来越大，因此某个点上的能量就越来越小。

定义和点光源的距离是1的时候，强度(intensity)是$I$，那么在距离为$r$的地方，
$$
I' = \frac{I}{r^2}
$$
这是由于能量守恒的原因。我们知道，
$$
I \cdot 4\pi r_0^2 = I' \cdot 4\pi r^2
$$
只需要带入$r_0 = 1$，就可以解出上面的结果。

依据上面二式，
$$
L_d = k_d \frac{I}{r^2}\max(0, \vec n \cdot \vec l)
$$
$L_d$就是漫反射光的光强，$k_d$为漫反射系数，如果用rgb值表示就变成了一个颜色，$I$是光源的单位化能量。

之所以要取max，是因为当点积结果是0，所成钝角，可以忽略不记。

漫反射的特点是，不论从什么地方看，得到的明暗都应当是完全一致，而和观察方向无关。所以，我们不需要考虑$\vec v$。

接下来考虑高光。对于高光来说，它的反射方向往往是沿着镜面反射方向的。

假设
$$
\vec h = (\vec l + \vec v)^0
$$
那么反射方向$\vec r$与$\vec v$接近，就等价于$\vec n, \vec h$接近。之所以要进行变换，主要是因为这样计算较为简单。

所以可以用点乘来逼近这种接近程度。为了简化模型，我们不考虑反射面对能量的吸收。
$$
L_s = k_s \frac{I}{r^2} \max (0, \vec n \cdot \vec h)^p
$$
如果$p=1$，那么这种高光的容忍度是非常高的，所以可能会看到一个很大很大的高光，但这和我们的经验是相悖的。为此我们引入指数项$p$，加大衰减速度。一般我们取$p$为100到200.

环境光是一个常数，保证没有地方完全是黑色的。

将三项相加，得到完整的Blinn-Phong模型
$$
L = k_aI_a + k_d \frac{I}{r^2}\max(0, \vec n \cdot \vec l) + k_s \frac{I}{r^2} \max(0, \vec n \cdot \vec h)^p
$$

## Shading Frequencies

着色频率实际上就是将着色应用在哪些点上。

将着色应用在顶点上和每个像素上，得到的结果会大不相同。

- Flat shading，在每个三角形做一个着色
- Gouraud shading，在每个顶点做一次着色，插值得到内部颜色结果
- Phong shading，对每一个像素做一次着色

具体在哪里着色，应当取决于具体模型。

同时，我们定义顶点的法线。顶点的法线与相邻面是有关的，可以定义
$$
N_v = \frac{\sum N_i}{||\sum N_i||}
$$
也可以用面积来加权，这样得到的结果会更好。

## Graphics Pipeline

渲染流水线。

Application -> Vertex Processing -> Triangle Processing -> Rasterization -> Fragment Processing -> Framebuffer Operations

着色可能发生在Vertex Processing，就是顶点的着色；也可能发生在Fragment Processing，就是逐像素着色。

决定这些着色的代码就是Shader，控制顶点和像素是如何着色的。现代GPU可控制部分主要也就是这部分。

如果写的是顶点的操作，就叫Vertex Shader；片元的操作，就叫Fragment Shader。

## Texture Mapping

我们希望有一种方法，定义物体上某个点的属性。

任意三维物体的表面都是二维的。因此，我们定义纹理是一张有弹性的图，蒙在物体表面。这种映射一般是由美术完成的，可以认为这种映射已经完成了。

在纹理上定义的坐标系就是U-V坐标系。一般，$U, V \in [0,1]$。

纹理可以应用到不同物体表面。将纹理不断进行重复，就得到了纹理映射的结果。可无缝设计的衔接就叫Tiling Texture。

假如我们知道三角形顶点对应坐标，那么如何在三角形内部做平滑过渡呢？可以使用Barycentric Coordinates(重心坐标)。

重心坐标是定义在三角形上的。假设三个顶点是$A,B,C$，那么三角形内任意一点$P$都可以表示成
$$
(x,y) = \alpha A + \beta B + \gamma C, \alpha + \beta + \gamma = 1
$$
当$\alpha, \beta, \gamma \ge 0$，则该点一定在三角形内。

而这个重心坐标恰好是可以用面积来表示的。连接$PA,PB,PC$，顶点$A$对的三角形面积是$S_A$，同理$S_B,S_C$，那么
$$
\alpha = \frac{S_A}{S_A + S_B + S_C}, \beta = \frac{S_B}{S_A+S_B+S_C},\gamma = \frac{S_C}{S_A+S_B+S_C}
$$
特别的，对三角形重心来说，恰好有
$$
(x, y) = \frac{1}{3}A + \frac{1}{3}B + \frac{1}{3}C
$$
将上式进一步化简，
$$
\alpha = \frac{-(x-x_B)(y_C-y_B) + (y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B) + (y_A-y_B) (x_C-x_B)}
$$

$$
\beta = \frac{-(x-x_C)(y_A-y_C) + (y-y_C)(x_A-x_C)}{-(x_A-x_B)(y_C-y_B) + (y_A-y_B) (x_C-x_B)}
$$

$$
\gamma = 1-\alpha - \beta
$$

将重心坐标直接应用到颜色等属性上插值，就可以得到任意一个点的值了。

不过缺点是，重心坐标在投影变换下，没有不变性。所以如果我们要插值三维空间属性，应该取三维坐标进行计算，而不能在投影之后的三角形中进行计算。其中最典型的就是深度属性，在计算的时候应该先找到对应三角形位置，逆变换得到三维空间坐标，之后进行深度插值，再重新投影回来。

直接应用会出现Texture Magnification

（1）纹理太小

如果纹理太小，可能会出现小数的情况。对纹理上的像素(texel，纹素)进行简单的round操作，就会出现不连续的情况。

所以引入双线性插值(Bilinear Interpolation)。假设点$P$临近的四个点是$A,B,C,D$，定义线性插值
$$
\operatorname{lerp}(x, v_0, v_1) = v_0 + x (v_1-v_0)
$$
在$x$方向上做一次线性插值，在$y$方向上做一次线性插值，就得到了$P$的坐标。这样结果虽然变模糊了，但是至少不会有锯齿。

如果需要更高的质量，可以做双三次插值(Bicubic)等方法。

（2）纹理太大

如果纹理太大，远处会出现摩尔纹，近处出现锯齿。

在屏幕上，近处和远处覆盖区域是各不相同的。在远处，甚至有可能一个像素覆盖多个纹理——而这样采样显然是不合理的。

同样的，我们也可以利用MSAA来解决。但是这样代价是非常高昂的。

那么如何解决？避免采样！

这就是Mipmap，一种允许快速近似矩形范围查询的方法。

先提前计算纹理的$\log$层。第0层是原始图像，第1层将分辨率缩小一半，不断进行降分辨率。这样，额外存储量只多了$1/3$。

假设某个像素的坐标是$(u,v)_{00}$，那么将贴图空间变化到屏幕空间之后其边长就是
$$
L = \max \left(\sqrt{\left(\frac{\partial u}{\partial x}\right)^2+\left(\frac{\partial v}{\partial x}\right)^2},\sqrt{\left(\frac{\partial u}{\partial y}\right)^2+\left(\frac{\partial v}{\partial y}\right)^2}\right)
$$
其中$(u,v)$与$(x,y)$是映射的函数。

那么，
$$
D = \log L
$$
也就是说，假如一个区域被转化到了$4\times4$的区域，那么就可以查$D_2$在对应像素的值，这样查询的复杂度就降到了$O(1)$。

这样还是有问题，因为直接round的结果会有明显的断点。所以，做三次线性插值！前两次插值先找到两层纹理的对应位置的值，两个再进行插值，就得到了具体某个像素的坐标值。

Mipmap的缺陷在于，在远处出现Overblur。这是因为，它的查询是对于正方形查询的。

一种解决的办法是Anisotropic Filtering(各向异性过滤)。这一方法的核心就是，在长宽上分别进行压缩，使得查询区域从正方形变成了矩形。因此，这样能一定程度上优化这种查询。但是还是没有根本解决查询的变形问题。其开销会变成原本的三倍。

EWA Filtering做了进一步优化，多次查询一个圆范围。当然这样代价就比较高昂。

## Application of textures

（1）环境贴图

在GPU中，texture = memory + range query(filtering)。也就是说，可以将纹理看成一系列数据。

我们可以用纹理去描述环境光。一个经典的例子是犹他茶壶，在茶壶上反射出了窗户和门。

这样的假设是，环境光都来自于无限远处。可以认为在同一方向上的强度是一样的，没有实际的深度意义。

将环境光记录在球面上，并记录其展开后的结果，就成为了一张环境光纹理，也就是Spherical Map。

当然这样记录存在扭曲，为此可以将球分成几个部分。将球放到一个包围盒中，在不同面上把结果得到立方图中，得到了六个表面，也就是cube map。

——这就是天空盒。

（2）凹凸贴图（bump/normal map)

可以定义一个表面上任意一个点的相对高度。定义在基础表面沿法线方向的变化程度，这就形成了在不改变几何形体情况下、定义点的高度。

由于高度变化，就会影响法线变化，进而影响凹凸性变化。

换言之，我们其实是在每个点求了一个假的法线，让人觉得有凹凸的效果，但不改变实际表面。这就是凹凸贴图与法线贴图的应用。

考虑一点$P(u,v)$，先从一维出发考虑。假如原本法线是$(0,1)$，那么$dp \doteq c\cdot(h_{p+1}-h_p)$，则$\vec n = (-dp,1)^0$。

现在推广到二维。如果法线是$(0,0,1)$，那么
$$
\frac{\partial p}{\partial u} = c_1 (h(\vec u+1)-h(\vec u)),\frac{\partial p}{\partial v} = c_2 (h(\vec v+1)-h(\vec v))
$$
则
$$
\vec n = (-\frac{\partial p}{\partial u},-\frac{\partial p}{\partial v},1)
$$
这个结果是相对于局部坐标系而言的，也就是认为法线是$(0,0,1)$的坐标系。最后结果需要重新计算到世界坐标中。

在现代有时用displacement mapping（位移贴图），这种贴图实际上会让位移真实发生。凹凸贴图的边缘和投影是没办法修改的，而位移贴图则能完美修改这些问题。但是，使用这种贴图，原模型的三角形需要非常细致。否则，模型就没办法跟得上纹理的变化频率。

这就又是一个采样的问题了。DirectX提供了动态曲面细分，可以根据需要进行一些操作。

（3）三维纹理

如果让纹理定义空间中任意一点的值，实际上是定义了空间中任意一点的一个噪声函数。经过一系列的处理之后，可以变成需要的样子。

Perlin noise是常见的噪声函数。

这些纹理广泛应用到体积渲染中。

（4）Provide Precomputed Shading

在一些复杂的模型中，我们可能需要让某些点打一些阴影，可以将这些阴影存在纹理中。

类似的，把一些计算进行预处理的结果放在纹理里。